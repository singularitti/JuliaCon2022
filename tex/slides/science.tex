\subsection{Sciency, technical stuff}

\begin{frame}{Things we do in \ab{} calculations}
    \begin{itemize}
        \item Electronic structure computation
        \item Optimize input crystal/molecular structures
        \item Phonon vibrational spectra computation
        \item Helmholtz free energy calculation at finite temperature
        \item Linear elastic constants
        \item More...
    \end{itemize}
\end{frame}

\subsubsection{Binary dependencies and foreign function interface}

\begin{frame}{Build an artifact}

    Operations like finding the symmetry of a crystal,
    are very common in \ab{} calculations (usually the first step).
    Therefore, we need a good library to do this.

    There is a C library called \href{https://github.com/spglib/spglib}{\texttt{spglib}}
    that does this.
    To take this library in productive use, we need first put it in a container
    (``Artifacts''). Luckily, the amazing Julia community has made it possible:
    \href{https://github.com/JuliaBinaryWrappers/spglib_jll.jl}{\texttt{spglib_jll.jl}}.

\end{frame}

\begin{frame}{Foreign function interface}

    Now that we have an artifact that exports the functions of the C library,
    it may still be hard to use since it uses some C data structures and API still which may
    not be idiomatic Julia. Therefore, we need to wrap it with a higher level of APIs:
    \href{https://github.com/singularitti/Spglib.jl}{\texttt{Spglib.jl}} is built based on
    this expectation.

\end{frame}

\begin{frame}[allowframebreaks]{Parsers for \ab{} software input and output}

    This is usually hard since most \ab{} are written in Fortran and Julia does not (?)
    have a Fortran parser...

    \framebreak

    \begin{itemize}
        \item For example, \qe{}'s input adopts the \texttt{Namelist} data structure from
              Fortran, and Julia does not have a parser for that...
        \item I know a Python package called
              \href{https://github.com/marshallward/f90nml}{\texttt{f90nml}}, it works well.
              So it came to me that I might write a Julia package that calls that Python
              code.
        \item Therefore, I wrote a very preliminary package
              \href{https://github.com/singularitti/PyFortran90Namelists.jl}{\texttt{PyFortran90Namelists.jl}}
              since writing a parser is time-consuming for a non-CS student like me.
        \item However, it uses \texttt{PyCall.jl}, so sometimes people have trouble installing
              it if they already have Python installed
              (see \href{https://github.com/JuliaPy/PyCall.jl\#specifying-the-python-version}{``Specifying the Python version''}).
    \end{itemize}

    \framebreak

    For output files, it is even more complicated since they usually do not have a standard
    format, therefore lots of regular expressions need to be used.

    It is extremely tricky and error-prone. If you are not familiar with regular expressions,
    try \href{https://github.com/jkrumbiegel/ReadableRegex.jl}{\texttt{ReadableRegex.jl}} to help you build them.

\end{frame}
